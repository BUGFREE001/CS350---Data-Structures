#1



#include<stdio.h>
#include<stdlib.h>

//structure to represent the nodes of linked list
struct node{
int data;
struct node *next;
};

int length=0;//length variable keeps track of the length of the linked list
struct node *head=NULL;//head and last variables holds the address of the head and tail of the LL
struct node *last=NULL;

void insertNode(int data){//this method is to insert the node at the beginning of the list
//this method is for making a linked list for testing purpose
struct node *newNode=(struct node*)malloc(sizeof(struct node));
newNode->data=data;
struct node *temp=head;
length++;
if(head==NULL){
newNode->next=newNode;
head=newNode;
last=newNode;
}else{
last->next=newNode;
newNode->next=head;
head=newNode;
}

}

//this function is for deleting the node of the linked list based on key value
//it takes in address of the head and key to be deleted
struct node *cirLL_delete_key(struct node *head,int key){
if(head==NULL){//if the list is empty
printf("not necessary to delete anything\n");
}else{length--;
struct node *curr=head;
struct node *prev=last;
if(head->data==key){//if first element is the node to be deleted
prev->next=head->next;
head=head->next;
printf("%d is deleted\n",key);
return head;
}
do{//this is to traverse the list
if(curr->data==key){
printf("%d is deleted\n",key);
prev->next=curr->next;
return head;
}
prev=curr;
curr=curr->next;
}while(curr!=head);
//if the element is not present in the list
printf("Element is not in the list");
length++;

}
return head;
}

//this function is to delete the node based on index
struct node *cirLL_delete_index(struct node *head,int index)
{
int temp=1;
if(head==NULL || index<1 || index>length){//if the list is empty or the index specified is in valid
printf("not necessary to delete anything\n");
return head;
}
struct node *curr=head;
struct node *prev=last;

length--;
do{//traverse the list

if(temp==index && index==1){//if we wish to delete first element
prev->next=head->next;printf("%d is deleted\n",curr->data);
head=head->next;
return head;
}
if(temp==index){
printf("%d is deleted\n",curr->data);
prev->next=curr->next;
return head;
}
temp++;
prev=curr;
curr=curr->next;
}while(curr!=head);

return 0;

}



void printCLL(){//this function will traverse through the list and print the list elements
struct node *temp=head;
do{
printf("%d\n",temp->data);
temp=temp->next;
}while(temp!=head);
}


int main(){//driver method
int tem;
//I wrote a testing code to initially insert 5 elements into the list and then after testing the two mentioned functions
for(int i=1;i<=5;i++){
printf("Enter %d th element",i);
scanf("%d",&tem);
insertNode(tem);
}
printCLL();
printf("\nDeletion with key\n");

printf("Enter key to be deleted");
scanf("%d",&tem);
head=cirLL_delete_key(head,tem);//testing first function
printCLL();

printf("\nDeletion with Index\n");
printf("Enter the index of the element to be deleted\n");
scanf("%d",&tem);
head=cirLL_delete_index(head,tem);//testing second function
printCLL();

}







--------------------------------------------------------------------------------------------------------------------------------------



#2




#include <stdio.h>
#include <stdlib.h>
struct node
{
struct node * prev;
int data;
struct node * next;
};

void dul_LL_delete_index(struct node *ls,int n)
{
if (ls)
{
for(int i=0;i<n-2;i++)
{
ls=ls->next;
}
ls->next=ls->next->next;
ls->next->prev=ls;
}
  
else
{
printf("list is empty");
}
}
int main()
{
  
   struct node *head,*second,*third,*fourth,*temp;
   head= (struct node *)malloc(sizeof(struct node));
   second= (struct node *)malloc(sizeof(struct node));
   third= (struct node *)malloc(sizeof(struct node));
   fourth= (struct node *)malloc(sizeof(struct node));

// first node
   head->prev=NULL;
   head->data=11;
  
// second node

head->next=second;
second->prev=head;
second->data=9;
  
// third node

second->next=third;
third->prev=second;
third->data=13;

// fourth node

third->next=fourth;
fourth->prev=third;
fourth->data=8;
fourth->next=NULL;

  
   printf("Before deletion\n");
   temp=head;
   while(temp!=NULL)
   {
   printf("%d ",temp->data);
   temp=temp->next;
   }
  
dul_LL_delete_index(head,3);
printf("\n");

printf("After deletion\n");
    temp=head;
   while(temp!=NULL)
   {
   printf("%d ",temp->data);
   temp=temp->next;
   }
  
   return 0;
}






-----------------------------------------------------------------------------------------------------------------------------------



#3




Note: Do NOT use online complier when you run the code, to avoid warnings, please use other complier




#include <stdio.h>     

struct node{
        int data;
        struct node *previous;
        struct node *next;
};      
struct node *head, *tail = NULL;  
    void addNode(int data) {
        struct node *newNode = (struct node*)malloc(sizeof(struct node));
        newNode->data = data;
        if(head == NULL) {  
            head = tail = newNode;
            head->previous = NULL;
            tail->next = NULL;
        }
        else {  
            tail->next = newNode;
            newNode->previous = tail;
            tail = newNode;
            tail->next = NULL;
        }
    }
void sortList() {
        struct node *current = NULL, *index = NULL;
        int temp;
        if(head == NULL) {
            return;
        }
        else {
            for(current = head; current->next != NULL; current = current->next) {
                for(index = current->next; index != NULL; index = index->next) {
                    if(current->data > index->data) {
                        temp = current->data;
                        current->data = index->data;
                        index->data = temp;
                    }
                }
            }
        }
    }
void display() {
        struct node *current = head;
        if(head == NULL) {
            printf("List is empty\n");
            return;
        }
        printf("NULL<-Head");
        while(current != NULL) {
            printf("<=>%d",current->data);
            current = current->next;
        }
       printf("->NULL\n");
    }
int   srt_dul_LL(lst){
       char *string = lst, *ptr = string;
        while (*ptr) {
            if (isdigit(*ptr)) {
                long val = strtol(ptr, &ptr, 10);
                addNode(val);
            } else {
                ptr++;
            }
        }
        return 0;
   }
     
int main()
    {
       char string[20];
        printf("Enter LIST: ");
        scanf("%s", string);
        srt_dul_LL(string);
        printf("Original list: \n");
        display();
        sortList();
        printf("Sorted list: \n");
        display();
        return 0;
    }
    
    
    
    
    
-----------------------------------------------------------------------------------------------------------------------------------





#4



#include <stdio.h>

struct Node { //Creating a structure for node
char data;
struct node *previous;
struct node *next;
} *head,*last;


void push(struct Node** head, char data1)
{
struct Node* new1 = (struct Node*)malloc(sizeof(struct Node));
new1->data = data1;
new1->next = (*head);
new1->previous = NULL;
if ((*head) != NULL)
(*head)->previous = new1;
(*head) = new1;
}


void rev_dul_LL(struct Node **head)
{
struct Node *any = NULL;
struct Node *curr = *head;
while (curr != NULL) {
any = curr->previous;
curr->previous = curr->next;
curr->next = any;
curr = curr->previous; }
if(any != NULL )
*head = any->previous;
}


void print_doubly_LL(struct Node *node)
{
while(node != NULL){
printf("%c ", node->data);
node = node->next; }
}



int main(void) {
struct Node* head = NULL;
push(&head, 'R');
push(&head, 'a');
push(&head, 'd');
push(&head, 'A');
push(&head, 'r');
print_doubly_LL(head);
rev_dul_LL(&head);

printf("\nReversed Doubly Linked list will be:\n");

print_doubly_LL(head);


return 0;

}




