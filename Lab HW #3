#1



#include<stdio.h>
#include<stdlib.h>

//structure to represent the nodes of linked list
struct node{
int data;
struct node *next;
};

int length=0;//length variable keeps track of the length of the linked list
struct node *head=NULL;//head and last variables holds the address of the head and tail of the LL
struct node *last=NULL;

void insertNode(int data){//this method is to insert the node at the beginning of the list
//this method is for making a linked list for testing purpose
struct node *newNode=(struct node*)malloc(sizeof(struct node));
newNode->data=data;
struct node *temp=head;
length++;
if(head==NULL){
newNode->next=newNode;
head=newNode;
last=newNode;
}else{
last->next=newNode;
newNode->next=head;
head=newNode;
}

}

//this function is for deleting the node of the linked list based on key value
//it takes in address of the head and key to be deleted
struct node *cirLL_delete_key(struct node *head,int key){
if(head==NULL){//if the list is empty
printf("not necessary to delete anything\n");
}else{length--;
struct node *curr=head;
struct node *prev=last;
if(head->data==key){//if first element is the node to be deleted
prev->next=head->next;
head=head->next;
printf("%d is deleted\n",key);
return head;
}
do{//this is to traverse the list
if(curr->data==key){
printf("%d is deleted\n",key);
prev->next=curr->next;
return head;
}
prev=curr;
curr=curr->next;
}while(curr!=head);
//if the element is not present in the list
printf("Element is not in the list");
length++;

}
return head;
}

//this function is to delete the node based on index
struct node *cirLL_delete_index(struct node *head,int index)
{
int temp=1;
if(head==NULL || index<1 || index>length){//if the list is empty or the index specified is in valid
printf("not necessary to delete anything\n");
return head;
}
struct node *curr=head;
struct node *prev=last;

length--;
do{//traverse the list

if(temp==index && index==1){//if we wish to delete first element
prev->next=head->next;printf("%d is deleted\n",curr->data);
head=head->next;
return head;
}
if(temp==index){
printf("%d is deleted\n",curr->data);
prev->next=curr->next;
return head;
}
temp++;
prev=curr;
curr=curr->next;
}while(curr!=head);

return 0;

}



void printCLL(){//this function will traverse through the list and print the list elements
struct node *temp=head;
do{
printf("%d\n",temp->data);
temp=temp->next;
}while(temp!=head);
}


int main(){//driver method
int tem;
//I wrote a testing code to initially insert 5 elements into the list and then after testing the two mentioned functions
for(int i=1;i<=5;i++){
printf("Enter %d th element",i);
scanf("%d",&tem);
insertNode(tem);
}
printCLL();
printf("\nDeletion with key\n");

printf("Enter key to be deleted");
scanf("%d",&tem);
head=cirLL_delete_key(head,tem);//testing first function
printCLL();

printf("\nDeletion with Index\n");
printf("Enter the index of the element to be deleted\n");
scanf("%d",&tem);
head=cirLL_delete_index(head,tem);//testing second function
printCLL();

}







--------------------------------------------------------------------------------------------------------------------------------------



#2




#include <stdio.h>
#include <stdlib.h>
struct node
{
struct node * prev;
int data;
struct node * next;
};

void dul_LL_delete_index(struct node *ls,int n)
{
if (ls)
{
for(int i=0;i<n-2;i++)
{
ls=ls->next;
}
ls->next=ls->next->next;
ls->next->prev=ls;
}
  
else
{
printf("list is empty");
}
}
int main()
{
  
   struct node *head,*second,*third,*fourth,*temp;
   head= (struct node *)malloc(sizeof(struct node));
   second= (struct node *)malloc(sizeof(struct node));
   third= (struct node *)malloc(sizeof(struct node));
   fourth= (struct node *)malloc(sizeof(struct node));

// first node
   head->prev=NULL;
   head->data=11;
  
// second node

head->next=second;
second->prev=head;
second->data=9;
  
// third node

second->next=third;
third->prev=second;
third->data=13;

// fourth node

third->next=fourth;
fourth->prev=third;
fourth->data=8;
fourth->next=NULL;

  
   printf("Before deletion\n");
   temp=head;
   while(temp!=NULL)
   {
   printf("%d ",temp->data);
   temp=temp->next;
   }
  
dul_LL_delete_index(head,3);
printf("\n");

printf("After deletion\n");
    temp=head;
   while(temp!=NULL)
   {
   printf("%d ",temp->data);
   temp=temp->next;
   }
  
   return 0;
}






-----------------------------------------------------------------------------------------------------------------------------------



#3




#include <stdio.h>
#include<stdlib.h>
  

struct Node {
int data;
struct Node* prev;
struct Node* next;
};

struct Node* append(struct Node*list , int data)
{
struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
struct Node* current = list;
newNode->data = data;
newNode->next = NULL;
newNode->prev = NULL;
if(list == NULL) return newNode;
  
while(current->next!=NULL)current = current->next;
  
newNode->prev = current;
current->next = newNode;
return list;
}

void printList(struct Node *head)
{
struct Node *current= head;
while (current!=NULL)
{
printf("%d ",current->data);
current = current->next;
}
printf("\n\n");
}

void Sort(struct Node *head)
{
int isSwap;
struct Node *current,*lptr = NULL;

if (head == NULL)return;
do
{
isSwap = 0;
current = head;

while (current->next != lptr)
{
if (current->data > current->next->data)
{
int temp = current->data;
               current->data = current->next->data ;
               current->next->data = temp;
isSwap = 1;
}
current = current->next;
}
lptr = current;
}
while (isSwap);
}
  
int main()
{
struct Node* head = NULL;
head = append(head , 2);
head = append(head , 0);
head = append(head , 2);
head = append(head , 0);
printf("Unsorted List : ");
printList(head);

Sort(head);
   printf("Sorted List : ");
printList(head);

return 0;
}
    
    
    
    
-----------------------------------------------------------------------------------------------------------------------------------





#4



#include<stdio.h>
#include<stdlib.h>

struct Node {
char value;
struct Node* nextPointer;
struct Node* previousPointer;
};

typedef struct Node NODE;

NODE *head;

void reverse() {

NODE *temp = NULL;   
NODE *traversalNode = head;

while (traversalNode != NULL) {

temp = traversalNode->previousPointer;
traversalNode->previousPointer = traversalNode->nextPointer;
     
   //Storing temp into the traversalNode nextPointer
traversalNode->nextPointer = temp;
traversalNode = traversalNode->previousPointer;
}   

//Checking if the list is not empty or more than one node is present
   //Then set head as the temp->previousPointer
if(temp != NULL )
head = temp->previousPointer;
}

//Below function will insert a new node at the end of the doubly linked list with the value passed as parameter
void insertAtEnd(char value) {

NODE* newNode = (NODE*)malloc(sizeof(NODE));
  
   //Set the newNode->value as the parameter value
   newNode->value = value;
   newNode->nextPointer = NULL;
     
   //Checking the node which we are going to insert is a first node
if (head == NULL) {
newNode->previousPointer = NULL;
head = newNode;
}
   //Otherwise add the node at the end of the doubly linked list
   else{
       //Store the head into the traversalNode pointer
       NODE *traversalNode = head;
      
       //Traverse till we reach the last node
       while (traversalNode->nextPointer != NULL)
           traversalNode = traversalNode->nextPointer;
  
       traversalNode->nextPointer = newNode;
       newNode->previousPointer = traversalNode;
   }
  
}

//Below function will display the value of each node present inside the doubly linked list
void display(){

   //Storing head into the traversalNode
NODE* traversalNode=head;

//Iterate over each node of the doubly linked list
while (traversalNode != NULL) {
printf("%c ", traversalNode->value);
      
       //Point to the next node in the doubly linked list
traversalNode = traversalNode->nextPointer;
}

}

int main(){
   insertAtEnd('r');
   insertAtEnd('A');
   insertAtEnd('d');
   insertAtEnd('a');
   insertAtEnd('R');
   printf("Data in doubly linked list before reversing is\n");
   display();

   reverse();

   printf("\nData in doubly linked list after reversing is\n");
   display();
  
}



